//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace MercadoBitcoin.Client.Generated
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Client 
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public Client(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "api.mercadobitcoin.net/api/v4";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Get Fees From Asset
        /// </summary>
        /// <remarks>
        /// Request for asset's withdraw fee (network fee charge)
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="asset">Instrument asset in the form BASE(e.g. USDC)</param>
        /// <param name="network">Asset network. If not informed uses default network of the asset</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AssetFee> FeesAsync(string asset, string network)
        {
            return FeesAsync(asset, network, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get Fees From Asset
        /// </summary>
        /// <remarks>
        /// Request for asset's withdraw fee (network fee charge)
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="asset">Instrument asset in the form BASE(e.g. USDC)</param>
        /// <param name="network">Asset network. If not informed uses default network of the asset</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AssetFee> FeesAsync(string asset, string network, System.Threading.CancellationToken cancellationToken)
        {
            if (asset == null)
                throw new System.ArgumentNullException("asset");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "{asset}/fees"
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(asset, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/fees");
                    urlBuilder_.Append('?');
                    if (network != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("network")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(network, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AssetFee>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get OrderBook
        /// </summary>
        /// <remarks>
        /// Get current orderbook (depth of market) for the instrument.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="limit">Limit of orderbook response data per side (`asks`, `bids`). Max allowed 1000</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<OrderBookResponse> OrderbookAsync(string symbol, string limit)
        {
            return OrderbookAsync(symbol, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get OrderBook
        /// </summary>
        /// <remarks>
        /// Get current orderbook (depth of market) for the instrument.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="limit">Limit of orderbook response data per side (`asks`, `bids`). Max allowed 1000</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OrderBookResponse> OrderbookAsync(string symbol, string limit, System.Threading.CancellationToken cancellationToken)
        {
            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "{symbol}/orderbook"
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/orderbook");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OrderBookResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Trades
        /// </summary>
        /// <remarks>
        /// List trades (executions).
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="tid">Trade id to find</param>
        /// <param name="since">Since trade id to find</param>
        /// <param name="from">Unix timestamp (UTC) of the leftmost required bar</param>
        /// <param name="to">Unix timestamp (UTC) of the rightmost required bar. {from} is required</param>
        /// <param name="limit">Limit of results. Max 1000</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TradeResponse>> TradesAsync(string symbol, int? tid, int? since, int? from, int? to, int? limit)
        {
            return TradesAsync(symbol, tid, since, from, to, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Trades
        /// </summary>
        /// <remarks>
        /// List trades (executions).
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="tid">Trade id to find</param>
        /// <param name="since">Since trade id to find</param>
        /// <param name="from">Unix timestamp (UTC) of the leftmost required bar</param>
        /// <param name="to">Unix timestamp (UTC) of the rightmost required bar. {from} is required</param>
        /// <param name="limit">Limit of results. Max 1000</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TradeResponse>> TradesAsync(string symbol, int? tid, int? since, int? from, int? to, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "{symbol}/trades"
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/trades");
                    urlBuilder_.Append('?');
                    if (tid != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("tid")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(tid, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (since != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("since")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("from")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(from, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("to")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(to, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<TradeResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Accounts
        /// </summary>
        /// <remarks>
        /// Get a list of accounts owned by the user. Usually, MercadoBitcoin works with only one default account.
        /// </remarks>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AccountResponse>> AccountsAsync()
        {
            return AccountsAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Accounts
        /// </summary>
        /// <remarks>
        /// Get a list of accounts owned by the user. Usually, MercadoBitcoin works with only one default account.
        /// </remarks>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AccountResponse>> AccountsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts"
                    urlBuilder_.Append("accounts");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<AccountResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List orders
        /// </summary>
        /// <remarks>
        /// List orders from specific market (most recent first)
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>10 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="has_executions">Filter for orders with or without execution Example: has_executions=true</param>
        /// <param name="side">Order side to be filtered Enum: `buy` or `sell`</param>
        /// <param name="status">Order status Enum: `created`, `working`, `cancelled`, `filled`</param>
        /// <param name="id_from">Filter for orders from the entered order ID Example: id_from=5</param>
        /// <param name="id_to">Filter for orders up to the entered order ID Example: id_to=12</param>
        /// <param name="created_at_from">Filter for orders created from the timestamp (UTC) entered Example:created_at_from=1633538771</param>
        /// <param name="created_at_to">Filter for orders created up to the timestamp (UTC) entered Example:created_at_to=1633539132</param>
        /// <param name="executed_at_from">Filter for orders executed from the timestamp (UTC) entered Example:executed_at_from=1633538771</param>
        /// <param name="executed_at_to">Filter for orders executed up to the timestamp (UTC) entered Example:executed_at_to=1633539132</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<OrderResponse>> OrdersAllAsync(string symbol, string accountId, string has_executions, string side, string status, string id_from, string id_to, string created_at_from, string created_at_to, string executed_at_from, string executed_at_to)
        {
            return OrdersAllAsync(symbol, accountId, has_executions, side, status, id_from, id_to, created_at_from, created_at_to, executed_at_from, executed_at_to, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List orders
        /// </summary>
        /// <remarks>
        /// List orders from specific market (most recent first)
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>10 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="has_executions">Filter for orders with or without execution Example: has_executions=true</param>
        /// <param name="side">Order side to be filtered Enum: `buy` or `sell`</param>
        /// <param name="status">Order status Enum: `created`, `working`, `cancelled`, `filled`</param>
        /// <param name="id_from">Filter for orders from the entered order ID Example: id_from=5</param>
        /// <param name="id_to">Filter for orders up to the entered order ID Example: id_to=12</param>
        /// <param name="created_at_from">Filter for orders created from the timestamp (UTC) entered Example:created_at_from=1633538771</param>
        /// <param name="created_at_to">Filter for orders created up to the timestamp (UTC) entered Example:created_at_to=1633539132</param>
        /// <param name="executed_at_from">Filter for orders executed from the timestamp (UTC) entered Example:executed_at_from=1633538771</param>
        /// <param name="executed_at_to">Filter for orders executed up to the timestamp (UTC) entered Example:executed_at_to=1633539132</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<OrderResponse>> OrdersAllAsync(string symbol, string accountId, string has_executions, string side, string status, string id_from, string id_to, string created_at_from, string created_at_to, string executed_at_from, string executed_at_to, System.Threading.CancellationToken cancellationToken)
        {
            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/{symbol}/orders"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/orders");
                    urlBuilder_.Append('?');
                    if (has_executions != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("has_executions")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(has_executions, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (side != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("side")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(side, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (id_from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("id_from")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id_from, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (id_to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("id_to")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id_to, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (created_at_from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("created_at_from")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(created_at_from, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (created_at_to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("created_at_to")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(created_at_to, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (executed_at_from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("executed_at_from")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(executed_at_from, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (executed_at_to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("executed_at_to")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(executed_at_to, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<OrderResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Place order
        /// </summary>
        /// <remarks>
        /// Place a new order.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>3 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="payload">Request</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PlaceOrderResponse> OrdersPOSTAsync(string symbol, string accountId, PlaceOrderRequest payload)
        {
            return OrdersPOSTAsync(symbol, accountId, payload, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Place order
        /// </summary>
        /// <remarks>
        /// Place a new order.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>3 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="payload">Request</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PlaceOrderResponse> OrdersPOSTAsync(string symbol, string accountId, PlaceOrderRequest payload, System.Threading.CancellationToken cancellationToken)
        {
            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            if (payload == null)
                throw new System.ArgumentNullException("payload");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(payload, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/{symbol}/orders"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/orders");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PlaceOrderResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Cancel order
        /// </summary>
        /// <remarks>
        /// Cancel an existing order.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>3 requests/sec
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="orderId">Unique order identifier</param>
        /// <param name="async">Cancel an order asynchronously (default `true`)
        /// <br/>If `false` the order status response will be polled until is `cancelled`</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CancelOrderResponse> OrdersDELETEAsync(string accountId, string symbol, string orderId, bool? async)
        {
            return OrdersDELETEAsync(accountId, symbol, orderId, async, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Cancel order
        /// </summary>
        /// <remarks>
        /// Cancel an existing order.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>3 requests/sec
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="orderId">Unique order identifier</param>
        /// <param name="async">Cancel an order asynchronously (default `true`)
        /// <br/>If `false` the order status response will be polled until is `cancelled`</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CancelOrderResponse> OrdersDELETEAsync(string accountId, string symbol, string orderId, bool? async, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            if (orderId == null)
                throw new System.ArgumentNullException("orderId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/{symbol}/orders/{orderId}"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/orders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(orderId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (async != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("async")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(async, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CancelOrderResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get orders
        /// </summary>
        /// <remarks>
        /// Get unique order by identifier
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="orderId">Unique order identifier</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<OrderResponse> OrdersGETAsync(string symbol, string accountId, string orderId)
        {
            return OrdersGETAsync(symbol, accountId, orderId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get orders
        /// </summary>
        /// <remarks>
        /// Get unique order by identifier
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="orderId">Unique order identifier</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OrderResponse> OrdersGETAsync(string symbol, string accountId, string orderId, System.Threading.CancellationToken cancellationToken)
        {
            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            if (orderId == null)
                throw new System.ArgumentNullException("orderId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/{symbol}/orders/{orderId}"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/orders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(orderId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OrderResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Balances
        /// </summary>
        /// <remarks>
        /// Get balances for all markets, including fiat, for an account
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>3 requests/sec
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CryptoBalanceResponse>> BalancesAsync(string accountId)
        {
            return BalancesAsync(accountId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Balances
        /// </summary>
        /// <remarks>
        /// Get balances for all markets, including fiat, for an account
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>3 requests/sec
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CryptoBalanceResponse>> BalancesAsync(string accountId, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/balances"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/balances");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<CryptoBalanceResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get Tier
        /// </summary>
        /// <remarks>
        /// Get tier tax
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<GetTierResponse>> TierAsync(string accountId)
        {
            return TierAsync(accountId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get Tier
        /// </summary>
        /// <remarks>
        /// Get tier tax
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<GetTierResponse>> TierAsync(string accountId, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/tier"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/tier");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<GetTierResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get Trading Fees
        /// </summary>
        /// <remarks>
        /// Get your trading fees for each symbol
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL) Example:symbol=`BTC-BRL`</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetMarketFeesResponse> Fees2Async(string accountId, string symbol)
        {
            return Fees2Async(accountId, symbol, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get Trading Fees
        /// </summary>
        /// <remarks>
        /// Get your trading fees for each symbol
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL) Example:symbol=`BTC-BRL`</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetMarketFeesResponse> Fees2Async(string accountId, string symbol, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/{symbol}/fees"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/fees");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetMarketFeesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List all orders
        /// </summary>
        /// <remarks>
        /// List orders from all markets (most recent first)
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>3 requests/sec
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="has_executions">Filter for orders with or without execution Example: has_executions=true</param>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL) Example:symbol=`BTC-BRL`</param>
        /// <param name="status">Order status Example: status=`created,working,cancelled,filled`</param>
        /// <param name="size">Size quantity of orders to find Example: size=`1`</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ListAllOrdersResponse> OrdersGET2Async(string accountId, string has_executions, string symbol, string status, string size)
        {
            return OrdersGET2Async(accountId, has_executions, symbol, status, size, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List all orders
        /// </summary>
        /// <remarks>
        /// List orders from all markets (most recent first)
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>3 requests/sec
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="has_executions">Filter for orders with or without execution Example: has_executions=true</param>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL) Example:symbol=`BTC-BRL`</param>
        /// <param name="status">Order status Example: status=`created,working,cancelled,filled`</param>
        /// <param name="size">Size quantity of orders to find Example: size=`1`</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ListAllOrdersResponse> OrdersGET2Async(string accountId, string has_executions, string symbol, string status, string size, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/orders"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/orders");
                    urlBuilder_.Append('?');
                    if (has_executions != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("has_executions")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(has_executions, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (symbol != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("symbol")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (size != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("size")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(size, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListAllOrdersResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Positions
        /// </summary>
        /// <remarks>
        /// Get open positions (open orders) for an account.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbols">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL,LTC-BRL)</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<PositionResponse>> PositionsAsync(string accountId, string symbols)
        {
            return PositionsAsync(accountId, symbols, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Positions
        /// </summary>
        /// <remarks>
        /// Get open positions (open orders) for an account.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbols">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL,LTC-BRL)</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<PositionResponse>> PositionsAsync(string accountId, string symbols, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/positions"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/positions");
                    urlBuilder_.Append('?');
                    if (symbols != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("symbols")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(symbols, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<PositionResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Deposits
        /// </summary>
        /// <remarks>
        /// List the deposits made by a user for a symbol. Fiat deposits not included.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument asset in the form BASE (e.g. BTC)</param>
        /// <param name="limit">Limit of results. Max 10</param>
        /// <param name="page">Pagination of deposits</param>
        /// <param name="from">Unix timestamp (UTC) for the time and date from where you want to list deposits</param>
        /// <param name="to">Unix timestamp (UTC) for the time and date to where you want to list deposits</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Deposit>> DepositsAsync(string accountId, string symbol, string limit, string page, string from, string to)
        {
            return DepositsAsync(accountId, symbol, limit, page, from, to, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Deposits
        /// </summary>
        /// <remarks>
        /// List the deposits made by a user for a symbol. Fiat deposits not included.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument asset in the form BASE (e.g. BTC)</param>
        /// <param name="limit">Limit of results. Max 10</param>
        /// <param name="page">Pagination of deposits</param>
        /// <param name="from">Unix timestamp (UTC) for the time and date from where you want to list deposits</param>
        /// <param name="to">Unix timestamp (UTC) for the time and date to where you want to list deposits</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Deposit>> DepositsAsync(string accountId, string symbol, string limit, string page, string from, string to, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/wallet/{symbol}/deposits"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/wallet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/deposits");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (page != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("page")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(page, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("from")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(from, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("to")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(to, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Deposit>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get Deposit Address
        /// </summary>
        /// <remarks>
        /// Get the deposit addresses (wallet-in) and/or tag/memo. Deposits are only available for the main wallet when using multiwallet.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument asset in the form BASE (e.g. BTC)</param>
        /// <param name="network">Network of asset (for assets with more than one network), ignored if asset in present in one network only</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DepositAddresses> AddressesAsync(string accountId, string symbol, Network2? network)
        {
            return AddressesAsync(accountId, symbol, network, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get Deposit Address
        /// </summary>
        /// <remarks>
        /// Get the deposit addresses (wallet-in) and/or tag/memo. Deposits are only available for the main wallet when using multiwallet.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument asset in the form BASE (e.g. BTC)</param>
        /// <param name="network">Network of asset (for assets with more than one network), ignored if asset in present in one network only</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DepositAddresses> AddressesAsync(string accountId, string symbol, Network2? network, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/wallet/{symbol}/deposits/addresses"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/wallet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/deposits/addresses");
                    urlBuilder_.Append('?');
                    if (network != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("network")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(network, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DepositAddresses>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Fiat Deposits
        /// </summary>
        /// <remarks>
        /// List fiat deposits made by a user for a symbol. Only BRL supported.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument asset in the form BASE (e.g. BRL)</param>
        /// <param name="limit">Limit of results. Max 50. Default 10</param>
        /// <param name="page">Pagination of deposits. Begins at 1</param>
        /// <param name="from">Unix timestamp (UTC) for the time and date from where you want to list deposits. Filter by created_at field.</param>
        /// <param name="to">Unix timestamp (UTC) for the time and date to where you want to list deposits. Filter by created_at field.</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FiatDeposit>> Deposits2Async(string accountId, string symbol, string limit, string page, string from, string to)
        {
            return Deposits2Async(accountId, symbol, limit, page, from, to, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Fiat Deposits
        /// </summary>
        /// <remarks>
        /// List fiat deposits made by a user for a symbol. Only BRL supported.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument asset in the form BASE (e.g. BRL)</param>
        /// <param name="limit">Limit of results. Max 50. Default 10</param>
        /// <param name="page">Pagination of deposits. Begins at 1</param>
        /// <param name="from">Unix timestamp (UTC) for the time and date from where you want to list deposits. Filter by created_at field.</param>
        /// <param name="to">Unix timestamp (UTC) for the time and date to where you want to list deposits. Filter by created_at field.</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FiatDeposit>> Deposits2Async(string accountId, string symbol, string limit, string page, string from, string to, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/wallet/fiat/{symbol}/deposits"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/wallet/fiat/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/deposits");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (page != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("page")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(page, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("from")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(from, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("to")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(to, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<FiatDeposit>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Withdraw Coin
        /// </summary>
        /// <remarks>
        /// Request for cryptocurrency or Brazilian Real currency transfer. So, if the coin field is filled with "BRL", a withdraw will be made to the informed banking account. If the coin field is filled with a cryptocurrency, a withdraw will be made to the informed wallet address.
        /// <br/>IMPORTANT: It's only allowed the transfer to "reliable" destinations. The need to mark as safe a wallet address or banking account is a security measure. For cryptocurrency transfer, it's also needed email approval for the transfer.
        /// <br/>To mark a wallet address or banking account as "reliable", you need to have activates the ["Two-Factor Authentication (2FA)"](https://www.mercadobitcoin.com.br/twostep/) and have a ["Security PIN"](https://www.mercadobitcoin.com.br/configuracoes/palavrasegura/). This feature is available for all users that have an active API Trade Key.
        /// <br/>You can configure reliable destinations at ["Address Register"](https://www.mercadobitcoin.com.br/configuracoes/cadastro_endereco/) and/or ["Banking Accounts"](https://www.mercadobitcoin.com.br/configuracoes/contasbancarias/).
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Cryptocurrency or fiat, ex BTC, BRL, ETH.</param>
        /// <param name="payload">Request</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Withdraw> WithdrawPOSTAsync(string accountId, string symbol, WithdrawCoinRequest payload)
        {
            return WithdrawPOSTAsync(accountId, symbol, payload, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Withdraw Coin
        /// </summary>
        /// <remarks>
        /// Request for cryptocurrency or Brazilian Real currency transfer. So, if the coin field is filled with "BRL", a withdraw will be made to the informed banking account. If the coin field is filled with a cryptocurrency, a withdraw will be made to the informed wallet address.
        /// <br/>IMPORTANT: It's only allowed the transfer to "reliable" destinations. The need to mark as safe a wallet address or banking account is a security measure. For cryptocurrency transfer, it's also needed email approval for the transfer.
        /// <br/>To mark a wallet address or banking account as "reliable", you need to have activates the ["Two-Factor Authentication (2FA)"](https://www.mercadobitcoin.com.br/twostep/) and have a ["Security PIN"](https://www.mercadobitcoin.com.br/configuracoes/palavrasegura/). This feature is available for all users that have an active API Trade Key.
        /// <br/>You can configure reliable destinations at ["Address Register"](https://www.mercadobitcoin.com.br/configuracoes/cadastro_endereco/) and/or ["Banking Accounts"](https://www.mercadobitcoin.com.br/configuracoes/contasbancarias/).
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Cryptocurrency or fiat, ex BTC, BRL, ETH.</param>
        /// <param name="payload">Request</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Withdraw> WithdrawPOSTAsync(string accountId, string symbol, WithdrawCoinRequest payload, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            if (payload == null)
                throw new System.ArgumentNullException("payload");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(payload, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/wallet/{symbol}/withdraw"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/wallet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/withdraw");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Withdraw>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Withdraw Coin
        /// </summary>
        /// <remarks>
        /// List withdraws by coin.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument symbol in the form BASE or QUOTE</param>
        /// <param name="page">Pagination of withdraws</param>
        /// <param name="page_size">Pagination size of withdraws(max 50)</param>
        /// <param name="from">Unix timestamp (UTC) of the from required withdraw</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Withdraw>> WithdrawAllAsync(string accountId, string symbol, int? page, int? page_size, int? from)
        {
            return WithdrawAllAsync(accountId, symbol, page, page_size, from, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Withdraw Coin
        /// </summary>
        /// <remarks>
        /// List withdraws by coin.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument symbol in the form BASE or QUOTE</param>
        /// <param name="page">Pagination of withdraws</param>
        /// <param name="page_size">Pagination size of withdraws(max 50)</param>
        /// <param name="from">Unix timestamp (UTC) of the from required withdraw</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Withdraw>> WithdrawAllAsync(string accountId, string symbol, int? page, int? page_size, int? from, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/wallet/{symbol}/withdraw"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/wallet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/withdraw");
                    urlBuilder_.Append('?');
                    if (page != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("page")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(page, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (page_size != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("page_size")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(page_size, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("from")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(from, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Withdraw>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get Withdraw Coin
        /// </summary>
        /// <remarks>
        /// Get withdraw by coin and id.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument symbol in the form BASE or QUOTE</param>
        /// <param name="withdrawId">Withdraw identifier to find</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Withdraw> WithdrawGETAsync(string accountId, string symbol, string withdrawId)
        {
            return WithdrawGETAsync(accountId, symbol, withdrawId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get Withdraw Coin
        /// </summary>
        /// <remarks>
        /// Get withdraw by coin and id.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbol">Instrument symbol in the form BASE or QUOTE</param>
        /// <param name="withdrawId">Withdraw identifier to find</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Withdraw> WithdrawGETAsync(string accountId, string symbol, string withdrawId, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            if (withdrawId == null)
                throw new System.ArgumentNullException("withdrawId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/wallet/{symbol}/withdraw/{withdrawId}"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/wallet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/withdraw/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(withdrawId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Withdraw>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get Withdraw Limits
        /// </summary>
        /// <remarks>
        /// Get fiat and crypto withdraw limits. The limit considers withdraws of the last 24 hours. If the value returned is 0, it means that is not possible to withdraw the asset.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbols">Symbols to filter. Ex.: BTC,LTC,SHIB,BRL</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response> LimitsAsync(string accountId, string symbols)
        {
            return LimitsAsync(accountId, symbols, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get Withdraw Limits
        /// </summary>
        /// <remarks>
        /// Get fiat and crypto withdraw limits. The limit considers withdraws of the last 24 hours. If the value returned is 0, it means that is not possible to withdraw the asset.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="symbols">Symbols to filter. Ex.: BTC,LTC,SHIB,BRL</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response> LimitsAsync(string accountId, string symbols, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/wallet/withdraw/config/limits"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/wallet/withdraw/config/limits");
                    urlBuilder_.Append('?');
                    if (symbols != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("symbols")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(symbols, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get BRL Withdraw Config
        /// </summary>
        /// <remarks>
        /// Get configurations of BRL cashout. The configurations includes limits and fees information.
        /// </remarks>
        /// <param name="accountId">Account identifier.</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BRLWithdrawConfig> BRLAsync(string accountId)
        {
            return BRLAsync(accountId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get BRL Withdraw Config
        /// </summary>
        /// <remarks>
        /// Get configurations of BRL cashout. The configurations includes limits and fees information.
        /// </remarks>
        /// <param name="accountId">Account identifier.</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BRLWithdrawConfig> BRLAsync(string accountId, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/wallet/withdraw/config/BRL"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/wallet/withdraw/config/BRL");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BRLWithdrawConfig>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Withdraw Crypto Wallet Addresses
        /// </summary>
        /// <remarks>
        /// List blockchain addresses available for API wallet outs. The addresses are previously registered and confirmed by the user. To get this information, the wallet address must be registered into the Automated Wallet Out process and the request must be done using the same IP also registered at the Automated Wallet Out process.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CryptoWalletAddress>> AddressesAllAsync(string accountId)
        {
            return AddressesAllAsync(accountId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Withdraw Crypto Wallet Addresses
        /// </summary>
        /// <remarks>
        /// List blockchain addresses available for API wallet outs. The addresses are previously registered and confirmed by the user. To get this information, the wallet address must be registered into the Automated Wallet Out process and the request must be done using the same IP also registered at the Automated Wallet Out process.
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CryptoWalletAddress>> AddressesAllAsync(string accountId, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/wallet/withdraw/addresses"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/wallet/withdraw/addresses");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<CryptoWalletAddress>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Withdraw Bank Accounts
        /// </summary>
        /// <remarks>
        /// List bank accounts available for API cash outs
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BankAccount>> BankAccountsAsync(string accountId)
        {
            return BankAccountsAsync(accountId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Withdraw Bank Accounts
        /// </summary>
        /// <remarks>
        /// List bank accounts available for API cash outs
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BankAccount>> BankAccountsAsync(string accountId, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/wallet/withdraw/bank-accounts"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/wallet/withdraw/bank-accounts");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<BankAccount>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Authorize user to access
        /// </summary>
        /// <remarks>
        /// Username and password authentication.
        /// </remarks>
        /// <param name="payload">Request</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AuthorizeResponse> AuthorizeAsync(AuthorizeRequest payload)
        {
            return AuthorizeAsync(payload, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Authorize user to access
        /// </summary>
        /// <remarks>
        /// Username and password authentication.
        /// </remarks>
        /// <param name="payload">Request</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AuthorizeResponse> AuthorizeAsync(AuthorizeRequest payload, System.Threading.CancellationToken cancellationToken)
        {
            if (payload == null)
                throw new System.ArgumentNullException("payload");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(payload, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "authorize"
                    urlBuilder_.Append("authorize");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuthorizeResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Candles
        /// </summary>
        /// <remarks>
        /// Request for history bars (candles).
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="resolution">1m, 15m, 1h, 3h, 1d, 1w, 1M(for months)</param>
        /// <param name="from">Unix timestamp (UTC) of the leftmost required bar</param>
        /// <param name="to">Unix timestamp (UTC) of the rightmost required bar, including to. It can be in the future. In this case, the rightmost required bar is the latest available bar.</param>
        /// <param name="countback">Number of bars (higher priority than from) starting with to. If countback is set, from will be ignored.</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ListCandlesResponse> CandlesAsync(string symbol, string resolution, int? from, int to, int? countback)
        {
            return CandlesAsync(symbol, resolution, from, to, countback, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Candles
        /// </summary>
        /// <remarks>
        /// Request for history bars (candles).
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)</param>
        /// <param name="resolution">1m, 15m, 1h, 3h, 1d, 1w, 1M(for months)</param>
        /// <param name="from">Unix timestamp (UTC) of the leftmost required bar</param>
        /// <param name="to">Unix timestamp (UTC) of the rightmost required bar, including to. It can be in the future. In this case, the rightmost required bar is the latest available bar.</param>
        /// <param name="countback">Number of bars (higher priority than from) starting with to. If countback is set, from will be ignored.</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ListCandlesResponse> CandlesAsync(string symbol, string resolution, int? from, int to, int? countback, System.Threading.CancellationToken cancellationToken)
        {
            if (symbol == null)
                throw new System.ArgumentNullException("symbol");

            if (resolution == null)
                throw new System.ArgumentNullException("resolution");

            if (to == null)
                throw new System.ArgumentNullException("to");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "candles"
                    urlBuilder_.Append("candles");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("symbol")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("resolution")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(resolution, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("from")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(from, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Append(System.Uri.EscapeDataString("to")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(to, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (countback != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("countback")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(countback, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListCandlesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Symbols
        /// </summary>
        /// <remarks>
        /// Get a list of all instruments.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbols">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL,LTC-BRL)</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ListSymbolInfoResponse> SymbolsAsync(string symbols)
        {
            return SymbolsAsync(symbols, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Symbols
        /// </summary>
        /// <remarks>
        /// Get a list of all instruments.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbols">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL,LTC-BRL)</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ListSymbolInfoResponse> SymbolsAsync(string symbols, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "symbols"
                    urlBuilder_.Append("symbols");
                    urlBuilder_.Append('?');
                    if (symbols != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("symbols")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(symbols, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ListSymbolInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Tickers
        /// </summary>
        /// <remarks>
        /// Get current prices of the instrument.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbols">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL,LTC-BRL)</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TickerResponse>> TickersAsync(string symbols)
        {
            return TickersAsync(symbols, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Tickers
        /// </summary>
        /// <remarks>
        /// Get current prices of the instrument.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="symbols">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL,LTC-BRL)</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<TickerResponse>> TickersAsync(string symbols, System.Threading.CancellationToken cancellationToken)
        {
            if (symbols == null)
                throw new System.ArgumentNullException("symbols");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "tickers"
                    urlBuilder_.Append("tickers");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("symbols")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(symbols, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<TickerResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Networks From Asset
        /// </summary>
        /// <remarks>
        /// Retrieves the networks associated with a specific asset (networks available for withdrawal).Please note that assets in **pre-listing** or **delisted** status do not provide network information.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="asset">Instrument asset in the form BASE(e.g. BTC)</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Network>> NetworksAsync(string asset)
        {
            return NetworksAsync(asset, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Networks From Asset
        /// </summary>
        /// <remarks>
        /// Retrieves the networks associated with a specific asset (networks available for withdrawal).Please note that assets in **pre-listing** or **delisted** status do not provide network information.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/sec
        /// </remarks>
        /// <param name="asset">Instrument asset in the form BASE(e.g. BTC)</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Network>> NetworksAsync(string asset, System.Threading.CancellationToken cancellationToken)
        {
            if (asset == null)
                throw new System.ArgumentNullException("asset");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "{asset}/networks"
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(asset, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/networks");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Network>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OpenClient 
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public OpenClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "api.mercadobitcoin.net/api/v4";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Cancel all open orders
        /// </summary>
        /// <remarks>
        /// Cancel all open orders for an account.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/min
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="has_executions">Filter for orders with or without execution</param>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL) Example:symbol=`BTC-BRL`</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CancelOpenOrdersResponse>> OrdersAsync(string accountId, bool? has_executions, string symbol)
        {
            return OrdersAsync(accountId, has_executions, symbol, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Cancel all open orders
        /// </summary>
        /// <remarks>
        /// Cancel all open orders for an account.
        /// <br/>
        /// <br/>RATE LIMIT:
        /// <br/>
        /// <br/>1 requests/min
        /// </remarks>
        /// <param name="accountId">Account identifier. Obtained from List Accounts</param>
        /// <param name="has_executions">Filter for orders with or without execution</param>
        /// <param name="symbol">Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL) Example:symbol=`BTC-BRL`</param>
        /// <returns>Response schema:</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CancelOpenOrdersResponse>> OrdersAsync(string accountId, bool? has_executions, string symbol, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "accounts/{accountId}/cancel_all_open_orders"
                    urlBuilder_.Append("accounts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/cancel_all_open_orders");
                    urlBuilder_.Append('?');
                    if (has_executions != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("has_executions")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(has_executions, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (symbol != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("symbol")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(symbol, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<CancelOpenOrdersResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AccountResponse
    {

        /// <summary>
        /// Currency of the account.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// CurrencySign of the account.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("currencySign")]
        public string CurrencySign { get; set; }

        /// <summary>
        /// Account identifier (accountId)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Name of the account.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// Account type.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthorizeRequest
    {

        /// <summary>
        /// Login of user
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("login")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Login { get; set; }

        /// <summary>
        /// Password of user
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("password")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthorizeResponse
    {

        /// <summary>
        /// Access token acts as a session ID that the application uses for making requests. This token should be protected as if it were user credentials.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("access_token")]
        public string Access_token { get; set; }

        /// <summary>
        /// The time when the token is expired is represented as the number of seconds since the Unix epoch (00:00:00 UTC on 1 January 1970).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("expiration")]
        public int? Expiration { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CancelOpenOrdersResponse
    {

        /// <summary>
        /// Crypto symbol
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("crypto")]
        public string Crypto { get; set; }

        /// <summary>
        /// Fiat symbol
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fiat")]
        public string Fiat { get; set; }

        /// <summary>
        /// Unique order identifier
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("order_id")]
        public string Order_id { get; set; }

        /// <summary>
        /// String constants to describe an order type
        /// <br/>Enum: `limit`, `stoplimit` and `post-only`
        /// <br/>Type | Description
        /// <br/>----------|-------------
        /// <br/>limit | limit order
        /// <br/>stoplimit | stoplimit order
        /// <br/>post-only | post-only order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("order_type")]
        public string Order_type { get; set; }

        /// <summary>
        /// String constants to describe an order side
        /// <br/>Enum: `BID` and `ASK`
        /// <br/>Side | Description
        /// <br/>----------|-------------
        /// <br/>BID | purchase (buy) order
        /// <br/>ASK | sales (sell) order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("side")]
        public string Side { get; set; }

        /// <summary>
        /// Status of request (not order status)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetTierResponse
    {

        /// <summary>
        /// It's the tax tier of account
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("tier")]
        public string Tier { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetMarketFeesResponse
    {

        /// <summary>
        /// Base of the market
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("base")]
        public string Base { get; set; }

        /// <summary>
        /// Quote of the market
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("quote")]
        public string Quote { get; set; }

        /// <summary>
        /// Your maker fee of the market
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("maker_fee")]
        public string Maker_fee { get; set; }

        /// <summary>
        /// Your taker fee of the market
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("taker_fee")]
        public string Taker_fee { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CryptoBalanceResponse
    {

        /// <summary>
        /// Available amount
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("available")]
        public string Available { get; set; }

        /// <summary>
        /// On hold balance related to open orders
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("on_hold")]
        public string On_hold { get; set; }

        /// <summary>
        /// Symbol.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("symbol")]
        public string Symbol { get; set; }

        /// <summary>
        /// Total balance (available + on_hold)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("total")]
        public string Total { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Execution
    {

        /// <summary>
        /// Executed at timestamp (UTC)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("executed_at")]
        public double? Executed_at { get; set; }

        /// <summary>
        /// Transaction charged fee (%)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fee_rate")]
        public string Fee_rate { get; set; }

        /// <summary>
        /// Id of transaction
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("instrument")]
        public string Instrument { get; set; }

        /// <summary>
        /// Executed price
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("price")]
        public double? Price { get; set; }

        /// <summary>
        /// Executed quantity (volume)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("qty")]
        public string Qty { get; set; }

        /// <summary>
        /// Executed side
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("side")]
        public string Side { get; set; }

        /// <summary>
        /// Type of execution for the operation. Can be maker or taker
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("liquidity")]
        public string Liquidity { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Fees
    {

        /// <summary>
        /// Fixed fiat value charged in every cashout.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fixed_amount")]
        public string Fixed_amount { get; set; }

        /// <summary>
        /// Percentual of the total cashout value charged in the withdraw.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("percentual")]
        public string Percentual { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ListAllOrdersResponse
    {

        /// <summary>
        /// Items. List of orders
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("items")]
        public System.Collections.Generic.ICollection<Orders> Items { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OrderBookResponse
    {

        /// <summary>
        /// Array of Array of numbers (OrderbookItem)
        /// <br/>Array of arrays with two string elements - price and volume. It is sorted by price in asc order.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("asks")]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<string>> Asks { get; set; }

        /// <summary>
        /// Array of Array of numbers (OrderbookItem)
        /// <br/>Array of arrays with two string elements - price and volume. It is sorted by price in asc order.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("bids")]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<string>> Bids { get; set; }

        /// <summary>
        /// Timestamp when the orderbook was generated
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("timestamp")]
        public double? Timestamp { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OrderResponse
    {

        /// <summary>
        /// Simple average price. For stoplimit orders with no limit order triggered the displayed value will be `0.00000000`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("avgPrice")]
        public double? AvgPrice { get; set; }

        /// <summary>
        /// Cost used when placing the order (not considering fee application)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("cost")]
        public double? Cost { get; set; }

        /// <summary>
        /// Date of order creation timestamp (UTC)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("created_at")]
        public double? Created_at { get; set; }

        /// <summary>
        /// Executed order transactions
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("executions")]
        public System.Collections.Generic.ICollection<Execution> Executions { get; set; }

        /// <summary>
        /// External Identifier setted by client.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("externalId")]
        public string ExternalId { get; set; }

        /// <summary>
        /// Charged volume by fee application
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fee")]
        public string Fee { get; set; }

        /// <summary>
        /// Filled quantity. For stoplimit orders with no limit order triggered the displayed value will be `0.00000000`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("filledQty")]
        public string FilledQty { get; set; }

        /// <summary>
        /// Unique order identifier.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("instrument")]
        public string Instrument { get; set; }

        /// <summary>
        /// Limit price used when placing the limit order (not considering fee application)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("limitPrice")]
        public double? LimitPrice { get; set; }

        /// <summary>
        /// Volume used when placing the order (not considering fee application)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("qty")]
        public string Qty { get; set; }

        /// <summary>
        /// String constants to describe an order side
        /// <br/>Enum: `buy` `sell`
        /// <br/>Side | Description
        /// <br/>----------|-------------
        /// <br/>buy | purchase order
        /// <br/>sell | sales order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("side")]
        public string Side { get; set; }

        /// <summary>
        /// String constants to describe an order status.
        /// <br/>Enum: `created` `working` `cancelled` `filled`
        /// <br/>Status | Description
        /// <br/>----------|-------------
        /// <br/>created | order is created and waiting to be processed
        /// <br/>working | order is created but not fully executed yet
        /// <br/>cancelled | order is cancelled
        /// <br/>filled | order is fully executed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// Stop price trigger used when placing the stop limit order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("stopPrice")]
        public double? StopPrice { get; set; }

        /// <summary>
        /// Limit order id created when stop price is achieved.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("triggerOrderId")]
        public string TriggerOrderId { get; set; }

        /// <summary>
        /// String constants to describe an order type
        /// <br/>Enum: `market`, `limit`, `stoplimit` and `post-only`
        /// <br/>Type | Description
        /// <br/>----------|-------------
        /// <br/>market | market order
        /// <br/>limit | limit order
        /// <br/>stoplimit | stoplimit order
        /// <br/>post-only | post-only order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Date of last order update timestamp (UTC)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("updated_at")]
        public double? Updated_at { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Orders
    {

        /// <summary>
        /// Date of order creation timestamp (UTC)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("created_at")]
        public double? Created_at { get; set; }

        /// <summary>
        /// Filled Quantity. For stoplimit orders with no limit order triggered the displayed value will be `0.00000000`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("filledQty")]
        public string FilledQty { get; set; }

        /// <summary>
        /// Unique order identifier.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Instrument symbol in the form BASE-QUOTE(e.g. BTC-BRL)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("instrument")]
        public string Instrument { get; set; }

        /// <summary>
        /// Limit price used when placing the limit order (not considering fee application)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("limitPrice")]
        public double? LimitPrice { get; set; }

        /// <summary>
        /// Volume used when placing the order (not considering fee application)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("qty")]
        public string Qty { get; set; }

        /// <summary>
        /// String constants to describe an order side
        /// <br/>Enum: `buy` `sell`
        /// <br/>Side | Description
        /// <br/>----------|-------------
        /// <br/>buy | purchase order
        /// <br/>sell | sales order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("side")]
        public string Side { get; set; }

        /// <summary>
        /// String constants to describe an order status.
        /// <br/>Enum: `created` `working` `cancelled` `filled`
        /// <br/>Status | Description
        /// <br/>----------|-------------
        /// <br/>created | order is created and waiting to be processed
        /// <br/>working | order is created but not fully executed yet
        /// <br/>cancelled | order is cancelled
        /// <br/>filled | order is fully executed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// Stop price trigger used when placing the stop limit order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("stopPrice")]
        public double? StopPrice { get; set; }

        /// <summary>
        /// Limit order id created when stop price is achieved.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("triggerOrderId")]
        public string TriggerOrderId { get; set; }

        /// <summary>
        /// String constants to describe an order type
        /// <br/>Enum: `market`, `limit`, `stoplimit` and `post-only`
        /// <br/>Type | Description
        /// <br/>----------|-------------
        /// <br/>market | market order
        /// <br/>limit | limit order
        /// <br/>stoplimit | stoplimit order
        /// <br/>post-only | post-only order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Date of last order update timestamp (UTC)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("updated_at")]
        public double? Updated_at { get; set; }

        /// <summary>
        /// External customized order Id
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("external_id")]
        public string External_id { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PlaceOrderRequest
    {

        /// <summary>
        /// Create an order asynchronously (default `false`)
        /// <br/>If `true` the order status response can be `created`
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("async")]
        public bool? Async { get; set; }

        /// <summary>
        /// Quote currency amount to be spent (used only for orders with type `market` and side `buy`)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("cost")]
        public double? Cost { get; set; }

        /// <summary>
        /// External customized order Id
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("externalId")]
        public string ExternalId { get; set; }

        /// <summary>
        /// Limit price per base currency (used only for orders with type `limit`, `post-only` or `stoplimit`)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("limitPrice")]
        public double? LimitPrice { get; set; }

        /// <summary>
        /// Order quantity (volume). Required only if cost is not set
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("qty")]
        public string Qty { get; set; }

        /// <summary>
        /// String constants to describe an order side
        /// <br/>Enum: `buy` `sell`
        /// <br/>Side | Description
        /// <br/>----------|-------------
        /// <br/>buy | purchase order
        /// <br/>sell | sales order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("side")]
        public string Side { get; set; }

        /// <summary>
        /// Price that triggers a limit order creation (used only for orders with type `stoplimit`)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("stopPrice")]
        public double? StopPrice { get; set; }

        /// <summary>
        /// String constants to describe an order type
        /// <br/>Enum: `market`, `limit`, `stoplimit` and `post-only`
        /// <br/>Type | Description
        /// <br/>----------|-------------
        /// <br/>market | market order
        /// <br/>limit | limit order
        /// <br/>stoplimit | stoplimit order
        /// <br/>post-only | post-only order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PlaceOrderResponse
    {

        /// <summary>
        /// Unique alphanumeric order identifier
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("orderId")]
        public string OrderId { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CancelOrderResponse
    {

        /// <summary>
        /// If the option `async` was set to `true` you order may or may not be canceled. If not, you will receive the following message.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PositionResponse
    {

        /// <summary>
        /// Simple average price of position trades.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("avgPrice")]
        public double? AvgPrice { get; set; }

        /// <summary>
        /// Type of orders
        /// <br/>Type | Description
        /// <br/>----------|-------------
        /// <br/>limit | limit order
        /// <br/>post-only | post only order
        /// <br/>stoplimit | stoplimit order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("category")]
        public string Category { get; set; }

        /// <summary>
        /// Unique order identifier (orderId)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Instrument symbol in the form BASE-QUOTE (e.g. "BTC-BRL").
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("instrument")]
        public string Instrument { get; set; }

        /// <summary>
        /// Order quantity (volume)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("qty")]
        public string Qty { get; set; }

        /// <summary>
        /// Side of orders
        /// <br/>Side | Description
        /// <br/>----------|-------------
        /// <br/>buy | purchase order
        /// <br/>sell | sales order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("side")]
        public string Side { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TickerResponse
    {

        /// <summary>
        /// The last buy price.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("buy")]
        public string Buy { get; set; }

        /// <summary>
        /// Last update date in nanoseconds.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("date")]
        public int? Date { get; set; }

        /// <summary>
        /// The highest price
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("high")]
        public string High { get; set; }

        /// <summary>
        /// The last price.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("last")]
        public string Last { get; set; }

        /// <summary>
        /// The lowest price.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("low")]
        public string Low { get; set; }

        /// <summary>
        /// The first price.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("open")]
        public string Open { get; set; }

        /// <summary>
        /// Pair name. It is equal to the requested one.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("pair")]
        public string Pair { get; set; }

        /// <summary>
        /// The last sell price.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sell")]
        public string Sell { get; set; }

        /// <summary>
        /// The total volume.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("vol")]
        public string Vol { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TradeResponse
    {

        /// <summary>
        /// Amount of crypt transacted
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public string Amount { get; set; }

        /// <summary>
        /// Trade creation date
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("date")]
        public int? Date { get; set; }

        /// <summary>
        /// Price of trade
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("price")]
        public string Price { get; set; }

        /// <summary>
        /// Trade id
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("tid")]
        public int? Tid { get; set; }

        /// <summary>
        /// Type of trade(buy or sell)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Withdraw
    {

        /// <summary>
        /// Account of withdraw (if coin is fiat).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("account")]
        public string Account { get; set; }

        /// <summary>
        /// Address of withdraw (if coin is crypto).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("address")]
        public string Address { get; set; }

        /// <summary>
        /// Cryptocurrency or fiat, ex BTC, BRL, ETH.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coin")]
        public string Coin { get; set; }

        /// <summary>
        /// CreatedAt time of transaction
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("created_at")]
        public string Created_at { get; set; }

        /// <summary>
        /// Description of withdraw.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// Destination of withdraw
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("destination_tag")]
        public string Destination_tag { get; set; }

        /// <summary>
        /// Fee of withdrawal
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fee")]
        public string Fee { get; set; }

        /// <summary>
        /// Id of withdrawal transaction
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public double? Id { get; set; }

        /// <summary>
        /// NetQuantity for withdraw.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("net_quantity")]
        public string Net_quantity { get; set; }

        /// <summary>
        /// Network of withdraw
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("network")]
        public string Network { get; set; }

        /// <summary>
        /// Quantity for withdraw.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("quantity")]
        public string Quantity { get; set; }

        /// <summary>
        /// Status of withdraw
        /// <br/>Status | Description
        /// <br/>----------|-------------
        /// <br/>1 | open
        /// <br/>2 | done
        /// <br/>3 | canceled
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public int? Status { get; set; }

        /// <summary>
        /// Tx of coin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("tx")]
        public string Tx { get; set; }

        /// <summary>
        /// UpdatedAt time of transaction
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("updated_at")]
        public string Updated_at { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BRLWithdrawConfig
    {

        /// <summary>
        /// Minimum cashout value.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("limit_min")]
        public string Limit_min { get; set; }

        /// <summary>
        /// Maximum cashout value of bank account type saving.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("saving_limit_max")]
        public string Saving_limit_max { get; set; }

        /// <summary>
        /// 24 hours limit for fiat cashout.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("total_limit")]
        public string Total_limit { get; set; }

        /// <summary>
        /// 24 hours limit for fiat cashout used.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("used_limit")]
        public string Used_limit { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("fees")]
        public Fees Fees { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WithdrawCoinRequest
    {

        /// <summary>
        /// If your withdraw is fiat, inform id of bank account.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("account_ref")]
        public int? Account_ref { get; set; }

        /// <summary>
        /// If your withdraw is crypto, inform crypto wallet address.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("address")]
        public string Address { get; set; }

        /// <summary>
        /// Description withdraw. (Maximum 30 characters)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// Destination address tag or MEMO if it is required
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("destination_tag")]
        public string Destination_tag { get; set; }

        /// <summary>
        /// Network withdraw. This parameter is required for crypto with multiple networks, otherwise must be empty. Check [here](https://api.mercadobitcoin.net/api/v4/docs#tag/Public-Data/paths/~1{asset}~1networks/get) for available networks for a specific crypto.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("network")]
        public string Network { get; set; }

        /// <summary>
        /// Quantity for withdraw.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("quantity")]
        public string Quantity { get; set; }

        /// <summary>
        /// If your withdraw is crypto, inform fee for pay. Check [here](https://api.mercadobitcoin.net/api/v4/docs#tag/Public-Data/paths/~1symbols/get) for correct values.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("tx_fee")]
        public string Tx_fee { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BankAccount
    {

        /// <summary>
        /// Bank account id informed for fiat withdrawal.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("account_ref")]
        public int? Account_ref { get; set; }

        /// <summary>
        /// Bank code/number.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("bank_code")]
        public string Bank_code { get; set; }

        /// <summary>
        /// Bank name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("bank_name")]
        public string Bank_name { get; set; }

        /// <summary>
        /// Name of the withdrawal recipient entity.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("recipient_name")]
        public string Recipient_name { get; set; }

        /// <summary>
        /// Tax id of the withdrawal recipient entity.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("recipient_tax_id")]
        public string Recipient_tax_id { get; set; }

        /// <summary>
        /// Bank account branch.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("account_branch")]
        public string Account_branch { get; set; }

        /// <summary>
        /// Account number.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("account_number")]
        public string Account_number { get; set; }

        /// <summary>
        /// Account type. It can be CHECKING or SAVING
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("account_type")]
        public string Account_type { get; set; }

        /// <summary>
        /// Joint account holder.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("account_holder")]
        public string Account_holder { get; set; }

        /// <summary>
        /// Indicates if it is a joint account
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("joint_account")]
        public bool? Joint_account { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CryptoWalletAddress
    {

        /// <summary>
        /// Selected instrument asset (equal to the requested one)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("asset")]
        public string Asset { get; set; }

        /// <summary>
        /// Crypto wallet address.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("address")]
        public string Address { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ListCandlesResponse
    {

        /// <summary>
        /// Closing price (last trade) in the bucket interval
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("c")]
        public System.Collections.Generic.ICollection<string> C { get; set; }

        /// <summary>
        /// Highest price during the bucket interval
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("h")]
        public System.Collections.Generic.ICollection<string> H { get; set; }

        /// <summary>
        /// Lowest price during the bucket interval
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("l")]
        public System.Collections.Generic.ICollection<string> L { get; set; }

        /// <summary>
        /// Opening price (first trade) in the bucket interval
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("o")]
        public System.Collections.Generic.ICollection<string> O { get; set; }

        /// <summary>
        /// Bucket start time (UTC)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("t")]
        public System.Collections.Generic.ICollection<int> T { get; set; }

        /// <summary>
        /// Volume of trading activity during the bucket interval
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("v")]
        public System.Collections.Generic.ICollection<string> V { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ListSymbolInfoResponse
    {

        /// <summary>
        /// Base of symbol
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("base-currency")]
        public System.Collections.Generic.ICollection<string> BaseCurrency { get; set; }

        /// <summary>
        /// Quote of symbol
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        public System.Collections.Generic.ICollection<string> Currency { get; set; }

        /// <summary>
        /// Minimum value for deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("deposit-minimum")]
        public System.Collections.Generic.ICollection<string> DepositMinimum { get; set; }

        /// <summary>
        /// Description of a symbol. Will be displayed in the chart legend for this symbol.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public System.Collections.Generic.ICollection<string> Description { get; set; }

        /// <summary>
        /// If is exchange listed
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("exchange-listed")]
        public System.Collections.Generic.ICollection<bool> ExchangeListed { get; set; }

        /// <summary>
        /// This symbol is able to trade
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("exchange-traded")]
        public System.Collections.Generic.ICollection<bool> ExchangeTraded { get; set; }

        /// <summary>
        /// Minimum price difference between two consecutive orders on the orderbook
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("minmovement")]
        public System.Collections.Generic.ICollection<string> Minmovement { get; set; }

        /// <summary>
        /// Number of decimal digits allowed for the symbol price. It's presented in the form of a scale. Example: `1000` means 3 decimal digits
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("pricescale")]
        public System.Collections.Generic.ICollection<double> Pricescale { get; set; }

        /// <summary>
        /// Session that you can trade this symbol
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("session-regular")]
        public System.Collections.Generic.ICollection<string> SessionRegular { get; set; }

        /// <summary>
        /// This is the name of the symbol. (Base - Quote)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("symbol")]
        public System.Collections.Generic.ICollection<string> Symbol { get; set; }

        /// <summary>
        /// Timezone where symbol is trading
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("timezone")]
        public System.Collections.Generic.ICollection<string> Timezone { get; set; }

        /// <summary>
        /// Type of symbol
        /// <br/>Enum: `CRYPTO` `FAN_TOKEN` `DIGITAL_ASSET` `UTILITY_TOKEN` `DEFI`
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public System.Collections.Generic.ICollection<string> Type { get; set; }

        /// <summary>
        /// Minimum value for withdrawal
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("withdraw-minimum")]
        public System.Collections.Generic.ICollection<string> WithdrawMinimum { get; set; }

        /// <summary>
        /// Withdrawal fee in mercado bitcoin
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("withdrawal-fee")]
        public System.Collections.Generic.ICollection<string> WithdrawalFee { get; set; }

        /// <summary>
        /// Minimum price to place order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("min-price")]
        public System.Collections.Generic.ICollection<string> MinPrice { get; set; }

        /// <summary>
        /// Maximum price to place order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("max-price")]
        public System.Collections.Generic.ICollection<string> MaxPrice { get; set; }

        /// <summary>
        /// Minimum volume to place order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("min-volume")]
        public System.Collections.Generic.ICollection<string> MinVolume { get; set; }

        /// <summary>
        /// Maximum volume to place order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("max-volume")]
        public System.Collections.Generic.ICollection<string> MaxVolume { get; set; }

        /// <summary>
        /// Minimum cost to place order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("min-cost")]
        public System.Collections.Generic.ICollection<string> MinCost { get; set; }

        /// <summary>
        /// Maximum cost to place order
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("max-cost")]
        public System.Collections.Generic.ICollection<string> MaxCost { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AssetFee
    {

        /// <summary>
        /// Selected instrument asset (equal to the requested one)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("asset")]
        public string Asset { get; set; }

        /// <summary>
        /// Network of withdrawal
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("network")]
        public string Network { get; set; }

        /// <summary>
        /// Minimum asset quantity for deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("deposit_minimum")]
        public string Deposit_minimum { get; set; }

        /// <summary>
        /// Network confirmations required for confirm deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("deposit_confirmations_required")]
        public string Deposit_confirmations_required { get; set; }

        /// <summary>
        /// Minimum asset quantity for withdrawal
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("withdraw_minimum")]
        public string Withdraw_minimum { get; set; }

        /// <summary>
        /// Fee value to cover the transaction costs (matching value with the field "tx_fee" of the [POST/withdrawCoin endpoint](https://api.mercadobitcoin.net/api/v4/docs#tag/Wallet/paths/~1accounts~1{accountId}~1wallet~1{symbol}~1withdraw/post))
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("withdrawal_fee")]
        public string Withdrawal_fee { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Deposit
    {

        /// <summary>
        /// Address of deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("address")]
        public string Address { get; set; }

        /// <summary>
        /// Secondary address identifier for coins like XRP.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("address_tag")]
        public string Address_tag { get; set; }

        /// <summary>
        /// Amount of deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public string Amount { get; set; }

        /// <summary>
        /// Coin of deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coin")]
        public string Coin { get; set; }

        /// <summary>
        /// Confirmations for deposit X / Y, X = Current, Y = Required ( For this coins: "BRL", "BTC", "LTC", "BCH", "XRP", "ETH", the current is not showed )
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("confirmTimes")]
        public string ConfirmTimes { get; set; }

        /// <summary>
        /// CreatedAt time of deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("createdAt")]
        public double? CreatedAt { get; set; }

        /// <summary>
        /// Network of deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("network")]
        public string Network { get; set; }

        /// <summary>
        /// List of sender addresses
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("origin")]
        public System.Collections.Generic.ICollection<string> Origin { get; set; }

        /// <summary>
        /// Status of deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// TransactionId of operation on blockchain
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("transaction_id")]
        public string Transaction_id { get; set; }

        /// <summary>
        /// Type of transfer, internal or external
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("transferType")]
        public string TransferType { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Network
    {

        /// <summary>
        /// Cryptocurrency ex BTC, XLM, ETH.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coin")]
        public string Coin { get; set; }

        /// <summary>
        /// Network of withdrawal
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("network")]
        public string Network1 { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FiatDeposit
    {

        /// <summary>
        /// Fiat deposit identifier.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public int? Id { get; set; }

        /// <summary>
        /// Amount of deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public string Amount { get; set; }

        /// <summary>
        /// Coin of deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coin")]
        public string Coin { get; set; }

        /// <summary>
        /// Status of deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// Type of transfer. (e.g. pix)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("transferType")]
        public string TransferType { get; set; }

        /// <summary>
        /// Information from source of fiat deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("source")]
        public Source Source { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DepositAddresses
    {

        /// <summary>
        /// Asset extra deposit config
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("config")]
        public Config Config { get; set; }

        /// <summary>
        /// Array of addresses
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("addresses")]
        public System.Collections.Generic.ICollection<Addresses> Addresses { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Addresses
    {

        /// <summary>
        /// Deposit address in the selected network
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("hash")]
        public string Hash { get; set; }

        /// <summary>
        /// Asset extra information such as tag and/or memo
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("extra")]
        public Extra Extra { get; set; }

        /// <summary>
        /// QR code of address in base64 and its format
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("qrcode")]
        public Qrcode Qrcode { get; set; }

    }

    /// <summary>
    /// Network of asset (for assets with more than one network), ignored if asset in present in one network only
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Network2
    {

        [System.Runtime.Serialization.EnumMember(Value = @"stellar")]
        Stellar = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"ethereum")]
        Ethereum = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response
    {

        /// <summary>
        /// Keys in the form of symbols and values in the form of quantity
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("symbol")]
        public string Symbol { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("example")]
        public object Example { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Source
    {

        /// <summary>
        /// Bank code/number.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("bank_code")]
        public string Bank_code { get; set; }

        /// <summary>
        /// Bank name.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("bank_name")]
        public string Bank_name { get; set; }

        /// <summary>
        /// Bank account branch.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("account_branch")]
        public string Account_branch { get; set; }

        /// <summary>
        /// Account number.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("account_number")]
        public string Account_number { get; set; }

        /// <summary>
        /// Creation unix timestamp
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("created_at")]
        public double? Created_at { get; set; }

        /// <summary>
        /// Last update unix timestamp
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("updated_at")]
        public double? Updated_at { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Config
    {

        /// <summary>
        /// Contract address of instrument in the selected network (if any)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("contract_address")]
        public string Contract_address { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Extra
    {

        /// <summary>
        /// Address tag and/or memo for deposit
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("address_tag")]
        public string Address_tag { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Qrcode
    {

        /// <summary>
        /// Deposit address of instrument in base64 encoded format
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("base64")]
        public string Base64 { get; set; }

        /// <summary>
        /// Image format after base64 decoding
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("format")]
        public string Format { get; set; }

    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765